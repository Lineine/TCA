<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Matrix.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">test_operational</a> &gt; <a href="index.source.html" class="el_package">net.mooctest</a> &gt; <span class="el_source">Matrix.java</span></div><h1>Matrix.java</h1><pre class="source lang-java linenums">package net.mooctest;

import java.io.Serializable;

/**
 * A generalized Matrix with n x m dimensions.
 * &lt;br /&gt;
 * &lt;h1&gt;Not Yet Implemented&lt;/h1&gt;
 * &lt;ul&gt;
 *  &lt;li&gt;Determinant&lt;/li&gt;
 *  &lt;li&gt;Inverse&lt;/li&gt;
 *  &lt;li&gt;LU-Decomposition&lt;/li&gt;
 *  &lt;li&gt;Multiply&lt;/li&gt;
 *  &lt;li&gt;Rank&lt;/li&gt;
 *  &lt;li&gt;Reduced Row Echelon Form&lt;/li&gt;
 *  &lt;li&gt;Row Echelon Form&lt;/li&gt;
 *  &lt;li&gt;Transpose&lt;/li&gt;
 * &lt;/ul&gt;
 * @version incomplete
 * @author mike, paul
 */
public class Matrix implements Serializable
{
    //&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Properties&quot;&gt;
    /**
     * Array of floats representing the data in the Matrix.
     */
    public final float[] data;

    /**
     * A integer that contains the number of rows in the Matrix.
     */
    public final int ROWS;

    /**
     * A integer that contains the number of columns in the Matrix.
     */
    public final int COLUMNS;
    //&lt;/editor-fold&gt;

    //&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Constructors&quot;&gt;
    /**
     * Complete Constructor / Default Constructor
     * Takes a array of floats and creates a new Matrix with the data.
     * @param data An array of floats containing the data of the Matrix.
     * @param rows Integer representing the number of rows in the Matrix.
     * @param columns Integer representing the number of columns in the Matrix.
     */
    public Matrix(float[] data, int rows, int columns)
<span class="fc" id="L50">    {</span>
        // If we have bad data throw a RuntimeException.
<span class="pc bpc" id="L52" title="3 of 6 branches missed.">        if(data == null || rows &lt; 1 || columns &lt; 1)</span>
<span class="nc" id="L53">            throw new InvalidDimensionsException();</span>
<span class="fc" id="L54">        this.data = data;</span>
<span class="fc" id="L55">        this.ROWS = rows;</span>
<span class="fc" id="L56">        this.COLUMNS = columns;</span>
<span class="fc" id="L57">    }</span>

    /**
     * Copy Constructor
     * Creates a copy of the matrix provided.
     * @param a A Matrix we want to copy.
     */
    public Matrix(Matrix a)
    {
<span class="fc" id="L66">        this(a.data, a.ROWS, a.COLUMNS);</span>
<span class="fc" id="L67">    }</span>
    //&lt;/editor-fold&gt;

    //&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Add&quot;&gt;
    /**
     * Performs addition with two Matrices.
     * @param a A Matrix to be added.
     * @param b A Matrix to be added.
     * @return Returns a + b.
     */
    public static Matrix add(Matrix a, Matrix b)
    {
<span class="fc" id="L79">        Matrix sum = null;</span>
<span class="pc bpc" id="L80" title="1 of 2 branches missed.">        if(a.data.length == b.data.length)</span>
        {
<span class="fc" id="L82">            float[] ws = new float[a.data.length];</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">            for (int i = 0; i &lt; a.data.length; i++)</span>
            {
<span class="fc" id="L85">                ws[i] = a.data[i] + b.data[i];</span>
            }
<span class="fc" id="L87">            sum = new Matrix(ws, a.ROWS, a.COLUMNS);</span>
        }
<span class="fc" id="L89">        return sum;</span>
    }

    /**
     * Performs addition with this Matrix and that Matrix.
     * @param that A Matrix to be added.
     * @return Returns this + that.
     */
    public Matrix add(Matrix that)
    {
<span class="fc" id="L99">        return Matrix.add(this, that);</span>
    }
    //&lt;/editor-fold&gt;

    //&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Determinant&quot;&gt;
    public static float determinant(Matrix a)
    {
<span class="nc" id="L106">        throw new UnsupportedOperationException(&quot;Not yet implemented.&quot;);</span>
    }

    public float determinant()
    {
<span class="nc" id="L111">        return Matrix.determinant(this);</span>
    }
    //&lt;/editor-fold&gt;

    //&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Divide&quot;&gt;
    /**
     * Divides each component of a Matrix by a scalar value.
     * @param a A Matrix we want to divide.
     * @param scalar A scalar value we want to divide by.
     * @return Returns A / scalar.
     */
    public static Matrix divide(Matrix a, float scalar)
    {
<span class="fc" id="L124">        float[] ws = new float[a.data.length];</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">        for(int i = 0; i &lt; ws.length; i++)</span>
<span class="fc" id="L126">            ws[i] = a.data[i] / scalar;</span>
<span class="fc" id="L127">        return new Matrix(ws, a.ROWS, a.COLUMNS);</span>
    }

    /**
     * Divides each component of this Matrix by a scalar value.
     * @param scalar A scalar value we want to divide by.
     * @return Returns this / scalar.
     */
    public Matrix divide(float scalar)
    {
<span class="fc" id="L137">        return Matrix.divide(this, scalar);</span>
    }

    /**
     * b Matrix divides a Matrix component wise.
     * @param a A Matrix we want to divide.
     * @param b A Matrix we want to divide.
     * @return Returns A / B.
     */
    public static Matrix divide(Matrix a, Matrix b)
    {
<span class="fc" id="L148">        Matrix quotient = null;</span>
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">        if(a.data.length == b.data.length)</span>
        {
<span class="fc" id="L151">            float[] ws = new float[a.data.length];</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">            for(int i = 0; i &lt; ws.length; i++)</span>
            {
<span class="fc" id="L154">                ws[i] = a.data[i] / b.data[i];</span>
            }
<span class="fc" id="L156">            quotient = new Matrix(ws, a.ROWS, a.COLUMNS);</span>
        }
<span class="fc" id="L158">        return quotient;</span>
    }

    /**
     * that Matrix divides this Matrix component wise.
     * @param that A Matrix we want to divide.
     * @return Returns this / that.
     */
    public Matrix divide(Matrix that)
    {
<span class="fc" id="L168">        return Matrix.divide(this, that);</span>
    }
    //&lt;/editor-fold&gt;

    //&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Equals&quot;&gt;
    /**
     * Compares this Matrix with another Object believed to be a Matrix.
     * @param obj An object believed to be a Matrix.
     * @return Returns the comparison of this == that.
     */
    @Override
    public boolean equals(Object obj)
    {
<span class="fc" id="L181">        boolean equals = false;</span>
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">        if(obj == this)</span>
<span class="nc" id="L183">            equals = true;</span>
<span class="pc bpc" id="L184" title="2 of 4 branches missed.">        else if(obj != null &amp;&amp; obj instanceof Matrix)</span>
        {
<span class="fc" id="L186">            Matrix that = (Matrix)obj;</span>
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">            if(this.data.length == that.data.length)</span>
            {
<span class="fc" id="L189">                equals = true;</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">                for(int i = 0; i &lt; this.data.length; i++)</span>
                {
<span class="fc bfc" id="L192" title="All 2 branches covered.">                    equals &amp;= (this.data[i] == that.data[i]);</span>
                }
            }
        }
<span class="fc" id="L196">        return equals;</span>
    }
    //&lt;/editor-fold&gt;

    //&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Helper Methods&quot;&gt;
    /**
     * Adds the data of two rows together.
     * @param row1 Data of a row to be added.
     * @param row2 Data of a row to be added.
     * @return row1 + row2.
     */
    private static float[] addRow(float[] row1, float[] row2)
    {
<span class="nc" id="L209">        float[] n_row = null;</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">        if(row1.length == row2.length)</span>
        {
<span class="nc" id="L212">            n_row = new float[row1.length];</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">            for(int i = 0; i &lt; row1.length; ++i)</span>
<span class="nc" id="L214">                n_row[i] = row1[i] + row2[i];</span>
        }
<span class="nc" id="L216">        return n_row;</span>
    }

    /**
     * Multiplies the data of a row by a scalar value.
     * @param row Data of a row to scale.
     * @param scalar A value to scale the row by.
     * @return Returns row * scalar.
     */
    private static float[] multiplyRow(float[] row, float scalar)
    {
<span class="nc" id="L227">        float[] ws = new float[row.length];</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">        for(int i = 0; i &lt; row.length; i++)</span>
<span class="nc" id="L229">            ws[i] = row[i] * scalar;</span>
<span class="nc" id="L230">        return ws;</span>
    }

    /**
     * Replaces a row in a 2D-Array.
     * @param a Data of Matrix with row to be replaced.
     * @param index Index of row to be replaced.
     * @param row Data of new row.
     */
    private static void replaceRow(float[][] a, int index, float[] row)
    {
<span class="nc" id="L241">        a[index] = row;</span>
<span class="nc" id="L242">    }</span>

    /**
     * Debug Method prints out row contents
     */
    private static void rowPrinter(float[] row)
    {
<span class="nc bnc" id="L249" title="All 2 branches missed.">        for(int i = 0; i &lt; row.length; i++)</span>
<span class="nc" id="L250">            System.out.print(row[i] + &quot; &quot;);</span>
<span class="nc" id="L251">        System.out.println(&quot;&quot;);</span>
<span class="nc" id="L252">    }</span>

    /**
     * Moves all rows containing all zero to the bottom of the Matrix.
     * @param a A float[][] containing the data of a Matrix.
     * @return Returns A Matrix with zeros in the proper locations for methods like rref.
     */
    private static float[][] swapZeros(float[][] a)
    {
<span class="nc" id="L261">        float[][] ws = a.clone();</span>
<span class="nc" id="L262">        int startIndex = ws.length - 1;</span>
<span class="nc" id="L263">        int endIndex = 0;</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">        for(int i = 0; i &lt; a.length; ++i)</span>
        {
<span class="nc bnc" id="L266" title="All 4 branches missed.">            if(startIndex &gt; endIndex &amp;&amp; Matrix.zeroRow(ws, i))</span>
            {
<span class="nc bnc" id="L268" title="All 2 branches missed.">                for(int j = startIndex; j &gt;= endIndex; --j)</span>
                {
<span class="nc bnc" id="L270" title="All 2 branches missed.">                    if(!Matrix.zeroRow(ws, j))</span>
                    {
<span class="nc" id="L272">                        Matrix.swapRows(ws, i, j);</span>
<span class="nc" id="L273">                        --startIndex; // With Each successful swap this zero row is now in place.</span>
<span class="nc" id="L274">                        break;</span>
                    }
                }
            }
<span class="nc" id="L278">            ++endIndex; // After Each iteration that row is considered sorted.</span>
        }
<span class="nc" id="L280">        return ws;</span>
    }

    /**
     * Swaps the rows of a float[][].
     * @param a A float[][] containing the data we want to swap the rows of.
     * @param r1 The index of a row we want to swap.
     * @param r2 The index of a row we want to swap.
     */
    private static void swapRows(float[][] a, int r1, int r2)
    {
<span class="nc" id="L291">        float[] temp = a[r1];</span>
<span class="nc" id="L292">        a[r1] = a[r2];</span>
<span class="nc" id="L293">        a[r2] = temp;</span>
<span class="nc" id="L294">    }</span>

    /**
     * Checks to see if a row is zero.
     * @param a A float[][] containing the data of a Matrix.
     * @param row The row index that we want to check.
     * @return Returns true if the row is all zeros.
     */
    private static boolean zeroRow(float[][] a, int row)
    {
<span class="nc" id="L304">        boolean zero = true;</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">        for(int i = 0; i &lt; a[0].length; ++i)</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">            zero &amp;= a[row][i] == 0;</span>
<span class="nc" id="L307">        return zero;</span>
    }
    //&lt;/editor-fold&gt;

    //&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Inverse&quot;&gt;
    public static Matrix inverse(Matrix a)
    {
<span class="nc" id="L314">        throw new UnsupportedOperationException(&quot;Not yet implemented.&quot;);</span>
    }

    public Matrix inverse()
    {
<span class="nc" id="L319">        return Matrix.inverse(this);</span>
    }
    //&lt;/editor-fold&gt;

    //&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;LU Decomposition&quot;&gt;
    public static Matrix[] luDecomposition(Matrix a)
    {
<span class="nc" id="L326">        throw new UnsupportedOperationException(&quot;Not yet implemented.&quot;);</span>
    }

    public Matrix[] luDecomposition()
    {
<span class="nc" id="L331">        return Matrix.luDecomposition(this);</span>
    }
    //&lt;/editor-fold&gt;

    //&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Multiply&quot;&gt;
    /**
     * Helper Method for multiplying the data of a Matrix
     * @param a Data of a matrix we want to multiply.
     * @param scalar A scalar value we want to multiply into the provided data.
     * @return Returns scalar * A
     */
    private static float[] multiply(float[] a, float scalar)
    {
<span class="fc" id="L344">        float[] ws = new float[a.length];</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">        for(int i = 0; i &lt; a.length; ++i)</span>
        {
<span class="fc" id="L347">            ws[i] = a[i] * scalar;</span>
        }
<span class="fc" id="L349">        return ws;</span>
    }

    /**
     * Multiplies a scalar value into the Matrix.
     * @param a A Matrix we want to multiply.
     * @param scalar A scalar value we want to multiply into the provided Matrix.
     * @return Returns scalar * A.
     */
    public static Matrix multiply(Matrix a, float scalar)
    {
<span class="fc" id="L360">        return new Matrix(Matrix.multiply(a.data, scalar), a.ROWS, a.COLUMNS);</span>
    }

    /**
     * Multiplies a scalar value into this Matrix.
     * @param scalar A scalar value we want to multiply into the provided Matrix.
     * @return Returns scalar * this.
     */
    public Matrix multiply(float scalar)
    {
<span class="fc" id="L370">        return Matrix.multiply(this, scalar);</span>
    }

    /**
     * Helper Method for Multiplying the data of two matrices.
     * @param a Data of a matrix we want to multiply.
     * @param b Data of a Matrix we want to multiply.
     * @return Returns a * b.
     */
    private static float[] multiply(float[] a, float[] b, int aRows, int aColumns, int bRows, int bColumns)
    {
<span class="fc" id="L381">        float[] product = null;</span>
<span class="pc bpc" id="L382" title="1 of 2 branches missed.">        if(aColumns == bRows)</span>
        {
<span class="fc" id="L384">            product = new float[aRows * bColumns];</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">            for(int k = 0; k &lt; aRows; k++)</span>
            {

            }
        }
<span class="fc" id="L390">        return product;</span>
    }

    /**
     * Perform Matrix multiplication between two matrices.
     * @param a A Matrix we want to multiply.
     * @param b A matrix we want to multiply.
     * @return Returns a * b.
     */
    public static Matrix multiply(Matrix a, Matrix b)
    {
<span class="fc" id="L401">        float[] mData = Matrix.multiply(a.data, b.data, a.ROWS, a.COLUMNS, b.ROWS, b.COLUMNS);</span>
<span class="fc" id="L402">        return new Matrix</span>
                (
                    mData,
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">                    (mData != null) ? a.ROWS : 0,</span>
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">                    (mData != null) ? b.COLUMNS : 0</span>
                );
    }

    /**
     * Perform Matrix multiplication between this Matrix and that Matrix.
     * @param that A Matrix we want to multiply.
     * @return Returns this * that.
     */
    public Matrix multiply(Matrix that)
    {
<span class="fc" id="L417">        return Matrix.multiply(this, that);</span>
    }
    //&lt;/editor-fold&gt;

    //&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Rank&quot;&gt;
    /**
     * Computes the rank of the provided Matrix.
     * @param a A Matrix we want to find the rank of.
     * @return Returns the ran of the Matrix.
     */
    public static int rank(Matrix a)
    {
<span class="nc" id="L429">        throw new UnsupportedOperationException(&quot;Not yet implemented.&quot;);</span>
    }

    /**
     * Computes the rank of this Matrix.
     * @return Returns the rank of this Matrix.
     */
    public int rank()
    {
<span class="nc" id="L438">        return Matrix.rank(this);</span>
    }
    //&lt;/editor-fold&gt;

    //&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Row Echelon Form (ref)&quot;&gt;
    /**
     * Finds the Row Echelon Form(ref) of the provided Matrix.
     * @param a A Matrix we want to find the Row Echelon Form of.
     * @return Returns a Matrix in Row Echelon Form.
     */
    public static Matrix ref(Matrix a)
    {
<span class="nc" id="L450">        throw new UnsupportedOperationException(&quot;Not yet implemented.&quot;);</span>
    }

    /**
     * Finds the Row Echelon Form(ref) of this Matrix.
     * @return Returns a Matrix in Row Echelon Form.
     */
    public Matrix ref()
    {
<span class="nc" id="L459">        return Matrix.ref(this);</span>
    }
    //&lt;/editor-fold&gt;

    //&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Reduced Row Echelon Form (rref)&quot;&gt;
    /**
     * Finds the Reduced Row Echelon Form(rref) of the provided Matrix.
     * @param a A Matrix we want to find the rref of.
     * @return Returns a Matrix in Reduced Row Echelon Form.
     */
    public static Matrix rref(Matrix a)
    {
<span class="nc" id="L471">        throw new UnsupportedOperationException(&quot;Not yet implemented.&quot;);</span>
    }

    /**
     * Finds the Reduced Row Echelon Form(rref) of this Matrix.
     * @return Returns a Matrix in Reduced Row Echelon Form.
     */
    public Matrix rref()
    {
<span class="nc" id="L480">        return Matrix.rref(this);</span>
    }
    //&lt;/editor-fold&gt;

    //&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Special Matrices&quot;&gt;
    /**
     * nxn Identity Matrix
     * @param n Integer defining the size of the Identity Matrix.
     * @return Returns a nxn Identity Matrix.
     */
    public static Matrix identity(int n)
    {
<span class="fc" id="L492">        float[] ws = new float[n * n];</span>
<span class="fc bfc" id="L493" title="All 2 branches covered.">        for(int i = 0; i &lt; n; ++i)</span>
<span class="fc" id="L494">            ws[i * n] = 1;</span>
<span class="fc" id="L495">        return new Matrix(ws, n, n);</span>
    }
    //&lt;/editor-fold&gt;

    //&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Subtract&quot;&gt;
    /**
     * Performs subtraction between two Matrices.
     * @param a A Matrix to be subtracted from.
     * @param b A Matrix to subtract by.
     * @return Returns a - b.
     */
    public static Matrix subtract(Matrix a, Matrix b)
    {
<span class="fc" id="L508">        Matrix difference = null;</span>
<span class="pc bpc" id="L509" title="1 of 2 branches missed.">        if(a.data.length == b.data.length)</span>
        {
<span class="fc" id="L511">            float[] ws = new float[a.data.length];</span>
<span class="fc bfc" id="L512" title="All 2 branches covered.">            for (int i = 0; i &lt; a.data.length; i++)</span>
            {
<span class="fc" id="L514">                ws[i] = a.data[i] - b.data[i];</span>
            }
<span class="fc" id="L516">            difference = new Matrix(ws, a.ROWS, a.COLUMNS);</span>
        }
<span class="fc" id="L518">        return difference;</span>
    }

    /**
     * Performs subtraction between this Matrix and that Matrix.
     * @param that A Matrix to subtract by.
     * @return Returns this - that.
     */
    public Matrix subtract(Matrix that)
    {
<span class="fc" id="L528">        return Matrix.subtract(this, that);</span>
    }
    //&lt;/editor-fold&gt;

    //&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;To-String&quot;&gt;
    /**
     * Produces a String representation of the Matrix.
     * @return Returns the String representation of the Matrix.
     */
    @Override
    public String toString()
    {
<span class="nc" id="L540">        throw new UnsupportedOperationException(&quot;Not yet implemented.&quot;);</span>
    }
    //&lt;/editor-fold&gt;

    //&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Transpose&quot;&gt;
    /**
     * Creates the transpose of a Matrix.
     * @param a A Matrix we want to transpose.
     * @return Returns the transpose of A.
     */
    public static Matrix transpose(Matrix a)
    {
<span class="nc" id="L552">        throw new UnsupportedOperationException(&quot;Not yet implemented.&quot;);</span>
    }

    /**
     * Creates the transpose of this Matrix.
     * @return Returns the transpose of this.
     */
    public Matrix transpose()
    {
<span class="nc" id="L561">        return Matrix.transpose(this);</span>
    }
    //&lt;/editor-fold&gt;

    //&lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Invalid Dimensions Exception&quot;&gt;
    /**
     * Custom Exception for Matrix classes.
     */
    private class InvalidDimensionsException extends RuntimeException
    {
        /**
         * Complete Constructor.
         * @param msg String containing the message outputted to console.
         */
        public InvalidDimensionsException(String msg)
<span class="nc" id="L576">        {</span>
<span class="nc" id="L577">            super(msg);</span>
<span class="nc" id="L578">        }</span>

        /**
         * Default Constructor.
         * Echos out the text &quot;The Dimensions of the Matrix are Invalid.&quot;
         */
        public InvalidDimensionsException()
<span class="nc" id="L585">        {</span>
<span class="nc" id="L586">            super(&quot;The Dimensions of the Matrix are Invalid.&quot;);</span>
<span class="nc" id="L587">        }</span>
    }
    //&lt;/editor-fold&gt;
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>