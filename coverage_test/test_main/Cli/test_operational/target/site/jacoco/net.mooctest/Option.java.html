<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Option.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">test_operational</a> &gt; <a href="index.source.html" class="el_package">net.mooctest</a> &gt; <span class="el_source">Option.java</span></div><h1>Option.java</h1><pre class="source lang-java linenums">/*
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the &quot;License&quot;); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
 */

package net.mooctest;

import static net.mooctest.Util.EMPTY_STRING_ARRAY;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * Describes a single command-line option. It maintains information regarding the short-name of the option, the long-name, if any exists, a flag indicating if
 * an argument is required for this option, and a self-documenting description of the option.
 * &lt;p&gt;
 * An Option is not created independently, but is created through an instance of {@link Options}. An Option is required to have at least a short or a long-name.
 * &lt;/p&gt;
 * &lt;p&gt;
 * &lt;b&gt;Note:&lt;/b&gt; once an {@link Option} has been added to an instance of {@link Options}, its required flag cannot be changed.
 * &lt;/p&gt;
 *
 * @see Options
 * @see CommandLine
 */
public class Option implements Cloneable, Serializable {

    /**
     * Builds {@code Option} instances using descriptive methods.
     * &lt;p&gt;
     * Example usage:
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * Option option = Option.builder(&quot;a&quot;).required(true).longOpt(&quot;arg-name&quot;).build();
     * &lt;/pre&gt;
     *
     * @since 1.3
     */
    public static final class Builder {

        /** The default type. */
<span class="fc" id="L57">        private static final Class&lt;String&gt; DEFAULT_TYPE = String.class;</span>

        /**
         * Returns the input Class or the default type (String) if null.
         *
         * @param type the candidate Class.
         * @return the input Class or the default type (String) if null.
         */
        private static Class&lt;?&gt; toType(final Class&lt;?&gt; type) {
<span class="fc bfc" id="L66" title="All 2 branches covered.">            return type != null ? type : DEFAULT_TYPE;</span>
        }

        /** The number of argument values this option can have. */
<span class="fc" id="L70">        private int argCount = UNINITIALIZED;</span>

        /** The name of the argument for this option. */
        private String argName;

        /** The converter to convert to type. **/
        private Converter&lt;?, ?&gt; converter;

        /** Specifies whether this option is deprecated. */
        private DeprecatedAttributes deprecated;

        /** Description of the option. */
        private String description;

        /** The long representation of the option. */
        private String longOption;

        /** The name of the option. */
        private String option;

        /** Specifies whether the argument value of this Option is optional. */
        private boolean optionalArg;

        /** Specifies whether this option is required to be present. */
        private boolean required;

        /** The type of this Option. */
<span class="fc" id="L97">        private Class&lt;?&gt; type = DEFAULT_TYPE;</span>

        /** The character that is the value separator. */
        private char valueSeparator;

        /**
         * Constructs a new {@code Builder} with the minimum required parameters for an {@code Option} instance.
         *
         * @param option short representation of the option.
         * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.
         */
<span class="fc" id="L108">        private Builder(final String option) throws IllegalArgumentException {</span>
<span class="fc" id="L109">            option(option);</span>
<span class="fc" id="L110">        }</span>

        /**
         * Sets the display name for the argument value.
         *
         * @param argName the display name for the argument value.
         * @return this builder, to allow method chaining.
         */
        public Builder argName(final String argName) {
<span class="fc" id="L119">            this.argName = argName;</span>
<span class="fc" id="L120">            return this;</span>
        }

        /**
         * Constructs an Option with the values declared by this {@link Builder}.
         *
         * @return the new {@link Option}.
         * @throws IllegalArgumentException if neither {@code opt} or {@code longOpt} has been set.
         */
        public Option build() {
<span class="pc bpc" id="L130" title="3 of 4 branches missed.">            if (option == null &amp;&amp; longOption == null) {</span>
<span class="nc" id="L131">                throw new IllegalArgumentException(&quot;Either opt or longOpt must be specified&quot;);</span>
            }
<span class="fc" id="L133">            return new Option(this);</span>
        }

        /**
         * Sets the converter for the option.
         *
         * &lt;p&gt;
         * Note: see {@link TypeHandler} for serialization discussion.
         * &lt;/p&gt;
         *
         * @param converter the Converter to use.
         * @return this builder, to allow method chaining.
         * @since 1.7.0
         */
        public Builder converter(final Converter&lt;?, ?&gt; converter) {
<span class="fc" id="L148">            this.converter = converter;</span>
<span class="fc" id="L149">            return this;</span>
        }

        /**
         * Marks this Option as deprecated.
         *
         * @return this builder.
         * @since 1.7.0
         */
        public Builder deprecated() {
<span class="fc" id="L159">            return deprecated(DeprecatedAttributes.DEFAULT);</span>
        }

        /**
         * Sets whether the Option is deprecated.
         *
         * @param deprecated specifies whether the Option is deprecated.
         * @return this builder.
         * @since 1.7.0
         */
        public Builder deprecated(final DeprecatedAttributes deprecated) {
<span class="fc" id="L170">            this.deprecated = deprecated;</span>
<span class="fc" id="L171">            return this;</span>
        }

        /**
         * Sets the description for this option.
         *
         * @param description the description of the option.
         * @return this builder, to allow method chaining.
         */
        public Builder desc(final String description) {
<span class="fc" id="L181">            this.description = description;</span>
<span class="fc" id="L182">            return this;</span>
        }

        /**
         * Tests whether the Option will require an argument.
         *
         * @return this builder, to allow method chaining.
         */
        public Builder hasArg() {
<span class="fc" id="L191">            return hasArg(true);</span>
        }

        /**
         * Tests whether the Option has an argument or not.
         *
         * @param hasArg specifies whether the Option takes an argument or not.
         * @return this builder, to allow method chaining.
         */
        public Builder hasArg(final boolean hasArg) {
            // set to UNINITIALIZED when no arg is specified to be compatible with OptionBuilder
<span class="fc bfc" id="L202" title="All 2 branches covered.">            argCount = hasArg ? 1 : UNINITIALIZED;</span>
<span class="fc" id="L203">            return this;</span>
        }

        /**
         * Tests whether the Option can have unlimited argument values.
         *
         * @return this builder.
         */
        public Builder hasArgs() {
<span class="nc" id="L212">            argCount = UNLIMITED_VALUES;</span>
<span class="nc" id="L213">            return this;</span>
        }

        /**
         * Sets the long name of the Option.
         *
         * @param longOpt the long name of the Option
         * @return this builder.
         */
        public Builder longOpt(final String longOpt) {
<span class="fc" id="L223">            this.longOption = longOpt;</span>
<span class="fc" id="L224">            return this;</span>
        }

        /**
         * Sets the number of argument values the Option can take.
         *
         * @param argCount the number of argument values
         * @return this builder.
         */
        public Builder numberOfArgs(final int argCount) {
<span class="nc" id="L234">            this.argCount = argCount;</span>
<span class="nc" id="L235">            return this;</span>
        }

        /**
         * Sets the name of the Option.
         *
         * @param option the name of the Option.
         * @return this builder.
         * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.
         * @since 1.5.0
         */
        public Builder option(final String option) throws IllegalArgumentException {
<span class="fc" id="L247">            this.option = OptionValidator.validate(option);</span>
<span class="fc" id="L248">            return this;</span>
        }

        /**
         * Sets whether the Option can have an optional argument.
         *
         * @param optionalArg specifies whether the Option can have an optional argument.
         * @return this builder.
         */
        public Builder optionalArg(final boolean optionalArg) {
<span class="nc bnc" id="L258" title="All 4 branches missed.">            if (optionalArg &amp;&amp; this.argCount == UNINITIALIZED) {</span>
<span class="nc" id="L259">                this.argCount = 1;</span>
            }
<span class="nc" id="L261">            this.optionalArg = optionalArg;</span>
<span class="nc" id="L262">            return this;</span>
        }

        /**
         * Marks this Option as required.
         *
         * @return this builder.
         */
        public Builder required() {
<span class="nc" id="L271">            return required(true);</span>
        }

        /**
         * Sets whether the Option is required.
         *
         * @param required specifies whether the Option is required.
         * @return this builder.
         */
        public Builder required(final boolean required) {
<span class="fc" id="L281">            this.required = required;</span>
<span class="fc" id="L282">            return this;</span>
        }

        /**
         * Sets the type of the Option.
         *
         * @param type the type of the Option.
         * @return this builder.
         */
        public Builder type(final Class&lt;?&gt; type) {
<span class="fc" id="L292">            this.type = toType(type);</span>
<span class="fc" id="L293">            return this;</span>
        }

        /**
         * The Option will use '=' as a means to separate argument value.
         *
         * @return this builder.
         */
        public Builder valueSeparator() {
<span class="nc" id="L302">            return valueSeparator(Char.EQUAL);</span>
        }

        /**
         * The Option will use {@code sep} as a means to separate argument values.
         * &lt;p&gt;
         * &lt;b&gt;Example:&lt;/b&gt;
         * &lt;/p&gt;
         *
         * &lt;pre&gt;
         * Option opt = Option.builder(&quot;D&quot;).hasArgs().valueSeparator('=').build();
         * Options options = new Options();
         * options.addOption(opt);
         * String[] args = { &quot;-Dkey=value&quot; };
         * CommandLineParser parser = new DefaultParser();
         * CommandLine line = parser.parse(options, args);
         * String propertyName = line.getOptionValues(&quot;D&quot;)[0]; // will be &quot;key&quot;
         * String propertyValue = line.getOptionValues(&quot;D&quot;)[1]; // will be &quot;value&quot;
         * &lt;/pre&gt;
         *
         * @param valueSeparator The value separator.
         * @return this builder.
         */
        public Builder valueSeparator(final char valueSeparator) {
<span class="fc" id="L326">            this.valueSeparator = valueSeparator;</span>
<span class="fc" id="L327">            return this;</span>
        }

    }

    /** Empty array. */
<span class="fc" id="L333">    static final Option[] EMPTY_ARRAY = {};</span>

    /** The serial version UID. */
    private static final long serialVersionUID = 1L;

    /** Specifies the number of argument values has not been specified. */
    public static final int UNINITIALIZED = -1;

    /** Specifies the number of argument values is infinite. */
    public static final int UNLIMITED_VALUES = -2;

    /**
     * Returns a {@link Builder} to create an {@link Option} using descriptive methods.
     *
     * @return a new {@link Builder} instance.
     * @since 1.3
     */
    public static Builder builder() {
<span class="nc" id="L351">        return builder(null);</span>
    }

    /**
     * Returns a {@link Builder} to create an {@link Option} using descriptive methods.
     *
     * @param option short representation of the option.
     * @return a new {@link Builder} instance.
     * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.
     * @since 1.3
     */
    public static Builder builder(final String option) {
<span class="fc" id="L363">        return new Builder(option);</span>
    }

    /** The number of argument values this option can have. */
<span class="fc" id="L367">    private int argCount = UNINITIALIZED;</span>

    /** The name of the argument for this option. */
    private String argName;

    /** The explicit converter for this option. May be null. */
    private transient Converter&lt;?, ?&gt; converter;

    /**
     * Specifies whether this option is deprecated, may be null.
     * &lt;p&gt;
     * If you want to serialize this field, use a serialization proxy.
     * &lt;/p&gt;
     */
    private final transient DeprecatedAttributes deprecated;

    /** Description of the option. */
    private String description;

    /** The long representation of the option. */
    private String longOption;

    /** The name of the option. */
    private final String option;

    /** Specifies whether the argument value of this Option is optional. */
    private boolean optionalArg;

    /** Specifies whether this option is required to be present. */
    private boolean required;

    /** The type of this Option. */
<span class="fc" id="L399">    private Class&lt;?&gt; type = String.class;</span>

    /** The list of argument values. **/
<span class="fc" id="L402">    private List&lt;String&gt; values = new ArrayList&lt;&gt;();</span>

    /** The character that is the value separator. */
    private char valuesep;

    /**
     * Private constructor used by the nested Builder class.
     *
     * @param builder builder used to create this option.
     */
<span class="fc" id="L412">    private Option(final Builder builder) {</span>
<span class="fc" id="L413">        this.argName = builder.argName;</span>
<span class="fc" id="L414">        this.description = builder.description;</span>
<span class="fc" id="L415">        this.longOption = builder.longOption;</span>
<span class="fc" id="L416">        this.argCount = builder.argCount;</span>
<span class="fc" id="L417">        this.option = builder.option;</span>
<span class="fc" id="L418">        this.optionalArg = builder.optionalArg;</span>
<span class="fc" id="L419">        this.deprecated = builder.deprecated;</span>
<span class="fc" id="L420">        this.required = builder.required;</span>
<span class="fc" id="L421">        this.type = builder.type;</span>
<span class="fc" id="L422">        this.valuesep = builder.valueSeparator;</span>
<span class="fc" id="L423">        this.converter = builder.converter;</span>
<span class="fc" id="L424">    }</span>

    /**
     * Creates an Option using the specified parameters.
     *
     * @param option      short representation of the option.
     * @param hasArg      specifies whether the Option takes an argument or not.
     * @param description describes the function of the option.
     *
     * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.
     */
    public Option(final String option, final boolean hasArg, final String description) throws IllegalArgumentException {
<span class="fc" id="L436">        this(option, null, hasArg, description);</span>
<span class="fc" id="L437">    }</span>

    /**
     * Creates an Option using the specified parameters. The option does not take an argument.
     *
     * @param option      short representation of the option.
     * @param description describes the function of the option.
     *
     * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.
     */
    public Option(final String option, final String description) throws IllegalArgumentException {
<span class="fc" id="L448">        this(option, null, false, description);</span>
<span class="fc" id="L449">    }</span>

    /**
     * Creates an Option using the specified parameters.
     *
     * @param option      short representation of the option.
     * @param longOption  the long representation of the option.
     * @param hasArg      specifies whether the Option takes an argument or not.
     * @param description describes the function of the option.
     *
     * @throws IllegalArgumentException if there are any non valid Option characters in {@code opt}.
     */
<span class="fc" id="L461">    public Option(final String option, final String longOption, final boolean hasArg, final String description) throws IllegalArgumentException {</span>
        // ensure that the option is valid
<span class="fc" id="L463">        this.deprecated = null;</span>
<span class="fc" id="L464">        this.option = OptionValidator.validate(option);</span>
<span class="fc" id="L465">        this.longOption = longOption;</span>
        // if hasArg is set then the number of arguments is 1
<span class="fc bfc" id="L467" title="All 2 branches covered.">        if (hasArg) {</span>
<span class="fc" id="L468">            this.argCount = 1;</span>
        }
<span class="fc" id="L470">        this.description = description;</span>
<span class="fc" id="L471">    }</span>

    /**
     * Tests whether the option can accept more arguments.
     *
     * @return false if the maximum number of arguments is reached.
     * @since 1.3
     */
    boolean acceptsArg() {
<span class="pc bpc" id="L480" title="6 of 10 branches missed.">        return (hasArg() || hasArgs() || hasOptionalArg()) &amp;&amp; (argCount &lt;= 0 || values.size() &lt; argCount);</span>
    }

    /**
     * Adds the value to this Option. If the number of arguments is greater than zero and there is enough space in the list then add the value. Otherwise, throw
     * a runtime exception.
     *
     * @param value The value to be added to this Option.
     */
    private void add(final String value) {
<span class="pc bpc" id="L490" title="1 of 2 branches missed.">        if (!acceptsArg()) {</span>
<span class="nc" id="L491">            throw new IllegalArgumentException(&quot;Cannot add value, list full.&quot;);</span>
        }
        // store value
<span class="fc" id="L494">        values.add(value);</span>
<span class="fc" id="L495">    }</span>

    /**
     * This method is not intended to be used. It was a piece of internal API that was made public in 1.0. It currently throws an UnsupportedOperationException.
     *
     * @param value the value to add.
     * @return always throws an {@link UnsupportedOperationException}.
     * @throws UnsupportedOperationException always.
     * @deprecated Unused.
     */
    @Deprecated
    public boolean addValue(final String value) {
<span class="fc" id="L507">        throw new UnsupportedOperationException(</span>
                &quot;The addValue method is not intended for client use. Subclasses should use the processValue method instead.&quot;);
    }

    /**
     * Clears the Option values. After a parse is complete, these are left with data in them and they need clearing if another parse is done.
     *
     * See: &lt;a href=&quot;https://issues.apache.org/jira/browse/CLI-71&quot;&gt;CLI-71&lt;/a&gt;
     */
    void clearValues() {
<span class="fc" id="L517">        values.clear();</span>
<span class="fc" id="L518">    }</span>

    /**
     * A rather odd clone method - due to incorrect code in 1.0 it is public and in 1.1 rather than throwing a CloneNotSupportedException it throws a
     * RuntimeException so as to maintain backwards compatible at the API level.
     *
     * After calling this method, it is very likely you will want to call clearValues().
     *
     * @return a clone of this Option instance.
     * @throws RuntimeException if a {@link CloneNotSupportedException} has been thrown by {@code super.clone()}.
     */
    @Override
    public Object clone() {
        try {
<span class="fc" id="L532">            final Option option = (Option) super.clone();</span>
<span class="fc" id="L533">            option.values = new ArrayList&lt;&gt;(values);</span>
<span class="fc" id="L534">            return option;</span>
<span class="nc" id="L535">        } catch (final CloneNotSupportedException e) {</span>
<span class="nc" id="L536">            throw new UnsupportedOperationException(e.getMessage(), e);</span>
        }
    }

    @Override
    public boolean equals(final Object obj) {
<span class="fc bfc" id="L542" title="All 2 branches covered.">        if (this == obj) {</span>
<span class="fc" id="L543">            return true;</span>
        }
<span class="pc bpc" id="L545" title="1 of 2 branches missed.">        if (!(obj instanceof Option)) {</span>
<span class="nc" id="L546">            return false;</span>
        }
<span class="fc" id="L548">        final Option other = (Option) obj;</span>
<span class="pc bpc" id="L549" title="1 of 4 branches missed.">        return Objects.equals(longOption, other.longOption) &amp;&amp; Objects.equals(option, other.option);</span>
    }

    /**
     * Gets the display name for the argument value.
     *
     * @return the display name for the argument value.
     */
    public String getArgName() {
<span class="fc" id="L558">        return argName;</span>
    }

    /**
     * Gets the number of argument values this Option can take.
     *
     * &lt;p&gt;
     * A value equal to the constant {@link #UNINITIALIZED} (= -1) indicates the number of arguments has not been specified. A value equal to the constant
     * {@link #UNLIMITED_VALUES} (= -2) indicates that this options takes an unlimited amount of values.
     * &lt;/p&gt;
     *
     * @return num the number of argument values.
     * @see #UNINITIALIZED
     * @see #UNLIMITED_VALUES
     */
    public int getArgs() {
<span class="fc" id="L574">        return argCount;</span>
    }

    /**
     * Gets the value to type converter.
     *
     * @return the value to type converter.
     * @since 1.7.0
     */
    public Converter&lt;?, ?&gt; getConverter() {
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">        return converter == null ? TypeHandler.getDefault().getConverter(type) : converter;</span>
    }

    /**
     * Gets deprecated attributes if any.
     *
     * @return boolean deprecated attributes or null.
     * @since 1.7.0
     */
    public DeprecatedAttributes getDeprecated() {
<span class="nc" id="L594">        return deprecated;</span>
    }

    /**
     * Gets the self-documenting description of this Option.
     *
     * @return The string description of this option.
     */
    public String getDescription() {
<span class="fc" id="L603">        return description;</span>
    }

    /**
     * Gets the id of this Option. This is only set when the Option shortOpt is a single character. This is used for switch statements.
     *
     * @return the id of this Option.
     */
    public int getId() {
<span class="nc" id="L612">        return getKey().charAt(0);</span>
    }

    /**
     * Gets the 'unique' Option identifier. This is the option value if set or the long value if the options value is not set.
     *
     * @return the 'unique' Option identifier.
     * @since 1.7.0
     */
    public String getKey() {
        // if 'opt' is null, then it is a 'long' option
<span class="pc bpc" id="L623" title="1 of 2 branches missed.">        return option == null ? longOption : option;</span>
    }

    /**
     * Gets the long name of this Option.
     *
     * @return Long name of this option, or null, if there is no long name.
     */
    public String getLongOpt() {
<span class="fc" id="L632">        return longOption;</span>
    }

    /**
     * Gets the name of this Option.
     *
     * It is this String which can be used with {@link CommandLine#hasOption(String opt)} and {@link CommandLine#getOptionValue(String opt)} to check for
     * existence and argument.
     *
     * @return The name of this option.
     */
    public String getOpt() {
<span class="fc" id="L644">        return option;</span>
    }

    /**
     * Gets the type of this Option.
     *
     * @return The type of this option.
     */
    public Object getType() {
<span class="fc" id="L653">        return type;</span>
    }

    /**
     * Gets the specified value of this Option or {@code null} if there is no value.
     *
     * @return the value/first value of this Option or {@code null} if there is no value.
     */
    public String getValue() {
<span class="pc bpc" id="L662" title="1 of 2 branches missed.">        return hasNoValues() ? null : values.get(0);</span>
    }

    /**
     * Gets the specified value of this Option or {@code null} if there is no value.
     *
     * @param index The index of the value to be returned.
     *
     * @return the specified value of this Option or {@code null} if there is no value.
     *
     * @throws IndexOutOfBoundsException if index is less than 1 or greater than the number of the values for this Option.
     */
    public String getValue(final int index) throws IndexOutOfBoundsException {
<span class="pc bpc" id="L675" title="1 of 2 branches missed.">        return hasNoValues() ? null : values.get(index);</span>
    }

    /**
     * Gets the value/first value of this Option or the {@code defaultValue} if there is no value.
     *
     * @param defaultValue The value to be returned if there is no value.
     *
     * @return the value/first value of this Option or the {@code defaultValue} if there are no values.
     */
    public String getValue(final String defaultValue) {
<span class="fc" id="L686">        final String value = getValue();</span>
<span class="pc bpc" id="L687" title="1 of 2 branches missed.">        return value != null ? value : defaultValue;</span>
    }

    /**
     * Gets the values of this Option as a String array or null if there are no values.
     *
     * @return the values of this Option as a String array or null if there are no values.
     */
    public String[] getValues() {
<span class="pc bpc" id="L696" title="1 of 2 branches missed.">        return hasNoValues() ? null : values.toArray(EMPTY_STRING_ARRAY);</span>
    }

    /**
     * Gets the value separator character.
     *
     * @return the value separator character.
     */
    public char getValueSeparator() {
<span class="fc" id="L705">        return valuesep;</span>
    }

    /**
     * Gets the values of this Option as a List or null if there are no values.
     *
     * @return the values of this Option as a List or null if there are no values.
     */
    public List&lt;String&gt; getValuesList() {
<span class="fc" id="L714">        return values;</span>
    }

    /**
     * Tests whether this Option requires an argument.
     *
     * @return boolean flag indicating if an argument is required.
     */
    public boolean hasArg() {
<span class="pc bpc" id="L723" title="1 of 4 branches missed.">        return argCount &gt; 0 || argCount == UNLIMITED_VALUES;</span>
    }

    /**
     * Tests whether the display name for the argument value has been set.
     *
     * @return if the display name for the argument value has been set.
     */
    public boolean hasArgName() {
<span class="pc bpc" id="L732" title="2 of 4 branches missed.">        return argName != null &amp;&amp; !argName.isEmpty();</span>
    }

    /**
     * Tests whether this Option can take many values.
     *
     * @return boolean flag indicating if multiple values are allowed.
     */
    public boolean hasArgs() {
<span class="pc bpc" id="L741" title="2 of 4 branches missed.">        return argCount &gt; 1 || argCount == UNLIMITED_VALUES;</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L746">        return Objects.hash(longOption, option);</span>
    }

    /**
     * Tests whether this Option has a long name.
     *
     * @return boolean flag indicating existence of a long name.
     */
    public boolean hasLongOpt() {
<span class="fc bfc" id="L755" title="All 2 branches covered.">        return longOption != null;</span>
    }

    /**
     * Tests whether this Option has any values.
     *
     * @return whether this Option has any values.
     */
    private boolean hasNoValues() {
<span class="fc" id="L764">        return values.isEmpty();</span>
    }

    /**
     * Tests whether this Option can have an optional argument.
     *
     * @return whether this Option can have an optional argument.
     */
    public boolean hasOptionalArg() {
<span class="fc" id="L773">        return optionalArg;</span>
    }

    /**
     * Tests whether this Option has specified a value separator.
     *
     * @return whether this Option has specified a value separator.
     * @since 1.1
     */
    public boolean hasValueSeparator() {
<span class="fc bfc" id="L783" title="All 2 branches covered.">        return valuesep &gt; 0;</span>
    }

    /**
     * Tests whether this Option is deprecated.
     *
     * @return boolean flag indicating whether this Option is deprecated.
     * @since 1.7.0
     */
    public boolean isDeprecated() {
<span class="fc bfc" id="L793" title="All 2 branches covered.">        return deprecated != null;</span>
    }

    /**
     * Tests whether this Option is required.
     *
     * @return boolean flag indicating whether this Option is required.
     */
    public boolean isRequired() {
<span class="fc" id="L802">        return required;</span>
    }

    /**
     * Processes the value. If this Option has a value separator the value will have to be parsed into individual tokens. When n-1 tokens have been processed
     * and there are more value separators in the value, parsing is ceased and the remaining characters are added as a single token.
     *
     * @param value The String to be processed.
     */
    void processValue(final String value) {
<span class="fc bfc" id="L812" title="All 2 branches covered.">        if (argCount == UNINITIALIZED) {</span>
<span class="fc" id="L813">            throw new IllegalArgumentException(&quot;NO_ARGS_ALLOWED&quot;);</span>
        }
<span class="fc" id="L815">        String add = value;</span>
        // this Option has a separator character
<span class="fc bfc" id="L817" title="All 2 branches covered.">        if (hasValueSeparator()) {</span>
            // get the separator character
<span class="fc" id="L819">            final char sep = getValueSeparator();</span>
            // store the index for the value separator
<span class="fc" id="L821">            int index = add.indexOf(sep);</span>
            // while there are more value separators
<span class="fc bfc" id="L823" title="All 2 branches covered.">            while (index != -1) {</span>
                // next value to be added
<span class="pc bpc" id="L825" title="1 of 2 branches missed.">                if (values.size() == argCount - 1) {</span>
<span class="fc" id="L826">                    break;</span>
                }
                // store
<span class="nc" id="L829">                add(add.substring(0, index));</span>
                // parse
<span class="nc" id="L831">                add = add.substring(index + 1);</span>
                // get new index
<span class="nc" id="L833">                index = add.indexOf(sep);</span>
            }
        }
        // store the actual value or the last value that has been parsed
<span class="fc" id="L837">        add(add);</span>
<span class="fc" id="L838">    }</span>

    /**
     * Tests whether the option requires more arguments to be valid.
     *
     * @return false if the option doesn't require more arguments.
     */
    boolean requiresArg() {
<span class="pc bpc" id="L846" title="1 of 2 branches missed.">        if (optionalArg) {</span>
<span class="nc" id="L847">            return false;</span>
        }
<span class="pc bpc" id="L849" title="1 of 2 branches missed.">        if (argCount == UNLIMITED_VALUES) {</span>
<span class="nc" id="L850">            return values.isEmpty();</span>
        }
<span class="fc" id="L852">        return acceptsArg();</span>
    }

    /**
     * Sets the display name for the argument value.
     *
     * @param argName the display name for the argument value.
     */
    public void setArgName(final String argName) {
<span class="fc" id="L861">        this.argName = argName;</span>
<span class="fc" id="L862">    }</span>

    /**
     * Sets the number of argument values this Option can take.
     *
     * @param num the number of argument values.
     */
    public void setArgs(final int num) {
<span class="fc" id="L870">        this.argCount = num;</span>
<span class="fc" id="L871">    }</span>

    /**
     * Sets the value to type converter.
     *
     * @param converter The converter to convert the string value to the type.
     * @since 1.7.0
     */
    public void setConverter(final Converter&lt;?, ?&gt; converter) {
<span class="fc" id="L880">        this.converter = converter;</span>
<span class="fc" id="L881">    }</span>

    /**
     * Sets the self-documenting description of this Option.
     *
     * @param description The description of this option.
     * @since 1.1
     */
    public void setDescription(final String description) {
<span class="nc" id="L890">        this.description = description;</span>
<span class="nc" id="L891">    }</span>

    /**
     * Sets the long name of this Option.
     *
     * @param longOpt the long name of this Option.
     */
    public void setLongOpt(final String longOpt) {
<span class="fc" id="L899">        this.longOption = longOpt;</span>
<span class="fc" id="L900">    }</span>

    /**
     * Sets whether this Option can have an optional argument.
     *
     * @param optionalArg specifies whether the Option can have an optional argument.
     */
    public void setOptionalArg(final boolean optionalArg) {
<span class="fc" id="L908">        this.optionalArg = optionalArg;</span>
<span class="fc" id="L909">    }</span>

    /**
     * Sets whether this Option is mandatory.
     *
     * @param required specifies whether this Option is mandatory.
     */
    public void setRequired(final boolean required) {
<span class="fc" id="L917">        this.required = required;</span>
<span class="fc" id="L918">    }</span>

    /**
     * Sets the type of this Option.
     *
     * @param type the type of this Option.
     * @since 1.3
     */
    public void setType(final Class&lt;?&gt; type) {
<span class="fc" id="L927">        this.type = Builder.toType(type);</span>
<span class="fc" id="L928">    }</span>

    /**
     * Sets the type of this Option.
     * &lt;p&gt;
     * &lt;b&gt;Note:&lt;/b&gt; this method is kept for binary compatibility and the input type is supposed to be a {@link Class} object.
     * &lt;/p&gt;
     *
     * @param type the type of this Option.
     * @deprecated since 1.3, use {@link #setType(Class)} instead.
     */
    @Deprecated
    public void setType(final Object type) {
<span class="nc" id="L941">        setType((Class&lt;?&gt;) type);</span>
<span class="nc" id="L942">    }</span>

    /**
     * Sets the value separator. For example if the argument value was a Java property, the value separator would be '='.
     *
     * @param sep The value separator.
     */
    public void setValueSeparator(final char sep) {
<span class="fc" id="L950">        this.valuesep = sep;</span>
<span class="fc" id="L951">    }</span>

    String toDeprecatedString() {
<span class="nc bnc" id="L954" title="All 2 branches missed.">        if (!isDeprecated()) {</span>
<span class="nc" id="L955">            return &quot;&quot;;</span>
        }
        // @formatter:off
<span class="nc" id="L958">        final StringBuilder buf = new StringBuilder()</span>
<span class="nc" id="L959">                .append(&quot;Option '&quot;)</span>
<span class="nc" id="L960">                .append(option)</span>
<span class="nc" id="L961">                .append(Char.APOS);</span>
        // @formatter:on
<span class="nc bnc" id="L963" title="All 2 branches missed.">        if (longOption != null) {</span>
<span class="nc" id="L964">            buf.append(Char.APOS).append(longOption).append(Char.APOS);</span>
        }
<span class="nc" id="L966">        buf.append(&quot;: &quot;).append(deprecated);</span>
<span class="nc" id="L967">        return buf.toString();</span>
    }

    /**
     * Creates a String suitable for debugging.
     *
     * @return a String suitable for debugging.
     */
    @Override
    public String toString() {
<span class="fc" id="L977">        final StringBuilder buf = new StringBuilder().append(&quot;[ &quot;);</span>
<span class="fc" id="L978">        buf.append(&quot;Option &quot;);</span>
<span class="fc" id="L979">        buf.append(option);</span>
<span class="fc bfc" id="L980" title="All 2 branches covered.">        if (longOption != null) {</span>
<span class="fc" id="L981">            buf.append(Char.SP).append(longOption);</span>
        }
<span class="pc bpc" id="L983" title="1 of 2 branches missed.">        if (isDeprecated()) {</span>
<span class="nc" id="L984">            buf.append(Char.SP);</span>
<span class="nc" id="L985">            buf.append(deprecated.toString());</span>
        }
<span class="pc bpc" id="L987" title="1 of 2 branches missed.">        if (hasArgs()) {</span>
<span class="nc" id="L988">            buf.append(&quot;[ARG...]&quot;);</span>
<span class="fc bfc" id="L989" title="All 2 branches covered.">        } else if (hasArg()) {</span>
<span class="fc" id="L990">            buf.append(&quot; [ARG]&quot;);</span>
        }
        // @formatter:off
<span class="fc" id="L993">        return buf.append(&quot; :: &quot;)</span>
<span class="fc" id="L994">            .append(description)</span>
<span class="fc" id="L995">            .append(&quot; :: &quot;)</span>
<span class="fc" id="L996">            .append(type)</span>
<span class="fc" id="L997">            .append(&quot; ]&quot;)</span>
<span class="fc" id="L998">            .toString();</span>
        // @formatter:on
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>