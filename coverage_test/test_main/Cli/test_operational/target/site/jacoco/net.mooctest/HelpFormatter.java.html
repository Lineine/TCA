<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HelpFormatter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">test_operational</a> &gt; <a href="index.source.html" class="el_package">net.mooctest</a> &gt; <span class="el_source">HelpFormatter.java</span></div><h1>HelpFormatter.java</h1><pre class="source lang-java linenums">/*
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the &quot;License&quot;); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
 */

package net.mooctest;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.Serializable;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.function.Function;
import java.util.function.Supplier;

/**
 * A formatter of help messages for command line options.
 * &lt;p&gt;
 * Example:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * Options options = new Options();
 * options.addOption(OptionBuilder.withLongOpt(&quot;file&quot;).withDescription(&quot;The file to be processed&quot;).hasArg().withArgName(&quot;FILE&quot;).isRequired().create('f'));
 * options.addOption(OptionBuilder.withLongOpt(&quot;version&quot;).withDescription(&quot;Print the version of the application&quot;).create('v'));
 * options.addOption(OptionBuilder.withLongOpt(&quot;help&quot;).create('h'));
 *
 * String header = &quot;Do something useful with an input file\n\n&quot;;
 * String footer = &quot;\nPlease report issues at https://example.com/issues&quot;;
 *
 * HelpFormatter formatter = new HelpFormatter();
 * formatter.printHelp(&quot;myapp&quot;, header, options, footer, true);
 * &lt;/pre&gt;
 * &lt;p&gt;
 * This produces the following output:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * usage: myapp -f &amp;lt;FILE&amp;gt; [-h] [-v]
 * Do something useful with an input file
 *
 *  -f,--file &amp;lt;FILE&amp;gt;   The file to be processed
 *  -h,--help
 *  -v,--version       Print the version of the application
 *
 * Please report issues at https://example.com/issues
 * &lt;/pre&gt;
 */
public class HelpFormatter {

    /**
     * Builds {@link HelpFormatter}.
     *
     * @since 1.7.0
     */
<span class="fc" id="L74">    public static final class Builder implements Supplier&lt;HelpFormatter&gt; {</span>
        // TODO All other instance HelpFormatter instance variables.
        // Make HelpFormatter immutable for 2.0

        /**
         * A function to convert a description (not null) and a deprecated Option (not null) to help description
         */
<span class="pc" id="L81">        private static final Function&lt;Option, String&gt; DEFAULT_DEPRECATED_FORMAT = o -&gt; &quot;[Deprecated] &quot; + getDescription(o);</span>

        /**
         * Formatter for deprecated options.
         */
<span class="fc" id="L86">        private Function&lt;Option, String&gt; deprecatedFormatFunc = DEFAULT_DEPRECATED_FORMAT;</span>

        /**
         * The output PrintWriter, defaults to wrapping {@link System#out}.
         */
<span class="fc" id="L91">        private PrintWriter printStream = createDefaultPrintWriter();</span>

        @Override
        public HelpFormatter get() {
<span class="fc" id="L95">            return new HelpFormatter(deprecatedFormatFunc, printStream);</span>
        }

        /**
         * Sets the output PrintWriter, defaults to wrapping {@link System#out}.
         *
         * @param printWriter the output PrintWriter, not null.
         * @return {@code this} instance.
         */
        public Builder setPrintWriter(final PrintWriter printWriter) {
<span class="nc" id="L105">            this.printStream = Objects.requireNonNull(printWriter, &quot;printWriter&quot;);</span>
<span class="nc" id="L106">            return this;</span>
        }

        /**
         * Sets whether to show deprecated options.
         *
         * @param useDefaultFormat if {@code true} use the default format, otherwise clear the formatter.
         * @return {@code this} instance.
         */
        public Builder setShowDeprecated(final boolean useDefaultFormat) {
<span class="nc bnc" id="L116" title="All 2 branches missed.">            return setShowDeprecated(useDefaultFormat ? DEFAULT_DEPRECATED_FORMAT : null);</span>
        }

        /**
         * Sets whether to show deprecated options.
         *
         * @param showDeprecatedFunc Specify the format for the deprecated options.
         * @return {@code this} instance.
         * @since 1.8.0
         */
        public Builder setShowDeprecated(final Function&lt;Option, String&gt; showDeprecatedFunc) {
<span class="fc" id="L127">            this.deprecatedFormatFunc = showDeprecatedFunc;</span>
<span class="fc" id="L128">            return this;</span>
        }
    }

    /**
     * This class implements the {@code Comparator} interface for comparing Options.
     */
    private static final class OptionComparator implements Comparator&lt;Option&gt;, Serializable {

        /** The serial version UID. */
        private static final long serialVersionUID = 5305467873966684014L;

        /**
         * Compares its two arguments for order. Returns a negative integer, zero, or a positive integer as the first argument
         * is less than, equal to, or greater than the second.
         *
         * @param opt1 The first Option to be compared.
         * @param opt2 The second Option to be compared.
         * @return a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than
         *         the second.
         */
        @Override
        public int compare(final Option opt1, final Option opt2) {
<span class="nc" id="L151">            return opt1.getKey().compareToIgnoreCase(opt2.getKey());</span>
        }
    }
    /** Default number of characters per line */
    public static final int DEFAULT_WIDTH = 74;

    /** Default padding to the left of each line */
    public static final int DEFAULT_LEFT_PAD = 1;

    /** Number of space characters to be prefixed to each description line */
    public static final int DEFAULT_DESC_PAD = 3;

    /** The string to display at the beginning of the usage statement */
    public static final String DEFAULT_SYNTAX_PREFIX = &quot;usage: &quot;;

    /** Default prefix for shortOpts */
    public static final String DEFAULT_OPT_PREFIX = &quot;-&quot;;

    /** Default prefix for long Option */
    public static final String DEFAULT_LONG_OPT_PREFIX = &quot;--&quot;;

    /**
     * Default separator displayed between a long Option and its value
     *
     * @since 1.3
     */
    public static final String DEFAULT_LONG_OPT_SEPARATOR = &quot; &quot;;

    /** Default name for an argument */
    public static final String DEFAULT_ARG_NAME = &quot;arg&quot;;

    /**
     * Creates a new builder.
     *
     * @return a new builder.
     * @since 1.7.0
     */
    public static Builder builder() {
<span class="fc" id="L189">        return new Builder();</span>
    }

    private static PrintWriter createDefaultPrintWriter() {
<span class="fc" id="L193">        return new PrintWriter(System.out);</span>
    }

    /**
     * Gets the option description or an empty string if the description is {@code null}.
     * @param option The option to get the description from.
     * @return the option description or an empty string if the description is {@code null}.
     * @since 1.8.0
     */
    public static String getDescription(final Option option) {
<span class="nc" id="L203">        final String desc = option.getDescription();</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">        return desc == null ? &quot;&quot; : desc;</span>
    }

    /**
     * Number of characters per line
     *
     * @deprecated Scope will be made private for next major version - use get/setWidth methods instead.
     */
<span class="fc" id="L212">    @Deprecated</span>
    public int defaultWidth = DEFAULT_WIDTH;

    /**
     * Amount of padding to the left of each line
     *
     * @deprecated Scope will be made private for next major version - use get/setLeftPadding methods instead.
     */
<span class="fc" id="L220">    @Deprecated</span>
    public int defaultLeftPad = DEFAULT_LEFT_PAD;

    /**
     * The number of characters of padding to be prefixed to each description line
     *
     * @deprecated Scope will be made private for next major version - use get/setDescPadding methods instead.
     */
<span class="fc" id="L228">    @Deprecated</span>
    public int defaultDescPad = DEFAULT_DESC_PAD;

    /**
     * The string to display at the beginning of the usage statement
     *
     * @deprecated Scope will be made private for next major version - use get/setSyntaxPrefix methods instead.
     */
<span class="fc" id="L236">    @Deprecated</span>
    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;

    /**
     * The new line string
     *
     * @deprecated Scope will be made private for next major version - use get/setNewLine methods instead.
     */
<span class="fc" id="L244">    @Deprecated</span>
<span class="fc" id="L245">    public String defaultNewLine = System.lineSeparator();</span>

    /**
     * The shortOpt prefix
     *
     * @deprecated Scope will be made private for next major version - use get/setOptPrefix methods instead.
     */
<span class="fc" id="L252">    @Deprecated</span>
    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;

    /**
     * The long Opt prefix
     *
     * @deprecated Scope will be made private for next major version - use get/setLongOptPrefix methods instead.
     */
<span class="fc" id="L260">    @Deprecated</span>
    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;

    /**
     * The name of the argument
     *
     * @deprecated Scope will be made private for next major version - use get/setArgName methods instead.
     */
<span class="fc" id="L268">    @Deprecated</span>
    public String defaultArgName = DEFAULT_ARG_NAME;

    /**
     * Comparator used to sort the options when they output in help text
     *
     * Defaults to case-insensitive alphabetical sorting by option key
     */
<span class="fc" id="L276">    protected Comparator&lt;Option&gt; optionComparator = new OptionComparator();</span>

    /**
     * Function to format the description for a deprecated option.
     */
    private final Function&lt;Option, String&gt; deprecatedFormatFunc;

    /**
     * Where to print help.
     */
    private final PrintWriter printWriter;

    /**
     * The separator displayed between the long option and its value.
     */
<span class="fc" id="L291">    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;</span>

    /**
     * Constructs a new instance.
     */
    public HelpFormatter() {
<span class="fc" id="L297">        this(null, createDefaultPrintWriter());</span>
<span class="fc" id="L298">    }</span>

    /**
     * Constructs a new instance.
     * @param printStream TODO
     */
<span class="fc" id="L304">    private HelpFormatter(final Function&lt;Option, String&gt; deprecatedFormatFunc, final PrintWriter printStream) {</span>
        // TODO All other instance HelpFormatter instance variables.
        // Make HelpFormatter immutable for 2.0
<span class="fc" id="L307">        this.deprecatedFormatFunc = deprecatedFormatFunc;</span>
<span class="fc" id="L308">        this.printWriter = printStream;</span>
<span class="fc" id="L309">    }</span>

    /**
     * Appends the usage clause for an Option to a StringBuffer.
     *
     * @param buff the StringBuffer to append to
     * @param option the Option to append
     * @param required whether the Option is required or not
     */
    private void appendOption(final StringBuffer buff, final Option option, final boolean required) {
<span class="nc bnc" id="L319" title="All 2 branches missed.">        if (!required) {</span>
<span class="nc" id="L320">            buff.append(&quot;[&quot;);</span>
        }
<span class="nc bnc" id="L322" title="All 2 branches missed.">        if (option.getOpt() != null) {</span>
<span class="nc" id="L323">            buff.append(&quot;-&quot;).append(option.getOpt());</span>
        } else {
<span class="nc" id="L325">            buff.append(&quot;--&quot;).append(option.getLongOpt());</span>
        }
        // if the Option has a value and a non blank argname
<span class="nc bnc" id="L328" title="All 6 branches missed.">        if (option.hasArg() &amp;&amp; (option.getArgName() == null || !option.getArgName().isEmpty())) {</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">            buff.append(option.getOpt() == null ? longOptSeparator : &quot; &quot;);</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">            buff.append(&quot;&lt;&quot;).append(option.getArgName() != null ? option.getArgName() : getArgName()).append(&quot;&gt;&quot;);</span>
        }
        // if the Option is not a required option
<span class="nc bnc" id="L333" title="All 2 branches missed.">        if (!required) {</span>
<span class="nc" id="L334">            buff.append(&quot;]&quot;);</span>
        }
<span class="nc" id="L336">    }</span>

    /**
     * Appends the usage clause for an OptionGroup to a StringBuffer. The clause is wrapped in square brackets if the group
     * is required. The display of the options is handled by appendOption
     *
     * @param buff the StringBuffer to append to
     * @param group the group to append
     * @see #appendOption(StringBuffer,Option,boolean)
     */
    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group) {
<span class="nc bnc" id="L347" title="All 2 branches missed.">        if (!group.isRequired()) {</span>
<span class="nc" id="L348">            buff.append(&quot;[&quot;);</span>
        }

<span class="nc" id="L351">        final List&lt;Option&gt; optList = new ArrayList&lt;&gt;(group.getOptions());</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">        if (getOptionComparator() != null) {</span>
<span class="nc" id="L353">            Collections.sort(optList, getOptionComparator());</span>
        }
        // for each option in the OptionGroup
<span class="nc bnc" id="L356" title="All 2 branches missed.">        for (final Iterator&lt;Option&gt; it = optList.iterator(); it.hasNext();) {</span>
            // whether the option is required or not is handled at group level
<span class="nc" id="L358">            appendOption(buff, it.next(), true);</span>

<span class="nc bnc" id="L360" title="All 2 branches missed.">            if (it.hasNext()) {</span>
<span class="nc" id="L361">                buff.append(&quot; | &quot;);</span>
            }
        }

<span class="nc bnc" id="L365" title="All 2 branches missed.">        if (!group.isRequired()) {</span>
<span class="nc" id="L366">            buff.append(&quot;]&quot;);</span>
        }
<span class="nc" id="L368">    }</span>

    /**
     * Creates a String of padding of length {@code len}.
     *
     * @param len The length of the String of padding to create.
     *
     * @return The String of padding
     */
    protected String createPadding(final int len) {
<span class="fc" id="L378">        final char[] padding = new char[len];</span>
<span class="fc" id="L379">        Arrays.fill(padding, ' ');</span>
<span class="fc" id="L380">        return new String(padding);</span>
    }

    /**
     * Finds the next text wrap position after {@code startPos} for the text in {@code text} with the column width
     * {@code width}. The wrap point is the last position before startPos+width having a whitespace character (space,
     * \n, \r). If there is no whitespace character before startPos+width, it will return startPos+width.
     *
     * @param text The text being searched for the wrap position
     * @param width width of the wrapped text
     * @param startPos position from which to start the lookup whitespace character
     * @return position on which the text must be wrapped or -1 if the wrap position is at the end of the text
     */
    protected int findWrapPos(final String text, final int width, final int startPos) {
        // the line ends before the max wrap pos or a new line char found
<span class="fc" id="L395">        int pos = text.indexOf(Char.LF, startPos);</span>
<span class="pc bpc" id="L396" title="3 of 4 branches missed.">        if (pos != -1 &amp;&amp; pos &lt;= width) {</span>
<span class="nc" id="L397">            return pos + 1;</span>
        }
<span class="fc" id="L399">        pos = text.indexOf(Char.TAB, startPos);</span>
<span class="pc bpc" id="L400" title="3 of 4 branches missed.">        if (pos != -1 &amp;&amp; pos &lt;= width) {</span>
<span class="nc" id="L401">            return pos + 1;</span>
        }
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">        if (startPos + width &gt;= text.length()) {</span>
<span class="fc" id="L404">            return -1;</span>
        }
        // look for the last whitespace character before startPos+width
<span class="nc bnc" id="L407" title="All 2 branches missed.">        for (pos = startPos + width; pos &gt;= startPos; --pos) {</span>
<span class="nc" id="L408">            final char c = text.charAt(pos);</span>
<span class="nc bnc" id="L409" title="All 6 branches missed.">            if (c == Char.SP || c == Char.LF || c == Char.CR) {</span>
<span class="nc" id="L410">                break;</span>
            }
        }
        // if we found it - just return
<span class="nc bnc" id="L414" title="All 2 branches missed.">        if (pos &gt; startPos) {</span>
<span class="nc" id="L415">            return pos;</span>
        }
        // if we didn't find one, simply chop at startPos+width
<span class="nc" id="L418">        pos = startPos + width;</span>

<span class="nc bnc" id="L420" title="All 2 branches missed.">        return pos == text.length() ? -1 : pos;</span>
    }

    /**
     * Gets the 'argName'.
     *
     * @return the 'argName'
     */
    public String getArgName() {
<span class="nc" id="L429">        return defaultArgName;</span>
    }

    /**
     * Gets the 'descPadding'.
     *
     * @return the 'descPadding'
     */
    public int getDescPadding() {
<span class="nc" id="L438">        return defaultDescPad;</span>
    }

    /**
     * Gets the 'leftPadding'.
     *
     * @return the 'leftPadding'
     */
    public int getLeftPadding() {
<span class="nc" id="L447">        return defaultLeftPad;</span>
    }

    /**
     * Gets the 'longOptPrefix'.
     *
     * @return the 'longOptPrefix'
     */
    public String getLongOptPrefix() {
<span class="nc" id="L456">        return defaultLongOptPrefix;</span>
    }

    /**
     * Gets the separator displayed between a long option and its value.
     *
     * @return the separator
     * @since 1.3
     */
    public String getLongOptSeparator() {
<span class="nc" id="L466">        return longOptSeparator;</span>
    }

    /**
     * Gets the 'newLine'.
     *
     * @return the 'newLine'
     */
    public String getNewLine() {
<span class="nc" id="L475">        return defaultNewLine;</span>
    }

    /**
     * Comparator used to sort the options when they output in help text. Defaults to case-insensitive alphabetical sorting
     * by option key.
     *
     * @return the {@link Comparator} currently in use to sort the options
     * @since 1.2
     */
    public Comparator&lt;Option&gt; getOptionComparator() {
<span class="fc" id="L486">        return optionComparator;</span>
    }

    /**
     * Gets the 'optPrefix'.
     *
     * @return the 'optPrefix'
     */
    public String getOptPrefix() {
<span class="nc" id="L495">        return defaultOptPrefix;</span>
    }

    /**
     * Gets the 'syntaxPrefix'.
     *
     * @return the 'syntaxPrefix'
     */
    public String getSyntaxPrefix() {
<span class="fc" id="L504">        return defaultSyntaxPrefix;</span>
    }

    /**
     * Gets the 'width'.
     *
     * @return the 'width'
     */
    public int getWidth() {
<span class="nc" id="L513">        return defaultWidth;</span>
    }

    /**
     * Prints the help for {@code options} with the specified command line syntax. This method prints help information
     * to  {@link System#out}  by default.
     *
     * @param width the number of characters to be displayed on each line
     * @param cmdLineSyntax the syntax for this application
     * @param header the banner to display at the beginning of the help
     * @param options the Options instance
     * @param footer the banner to display at the end of the help
     */
    public void printHelp(final int width, final String cmdLineSyntax, final String header, final Options options, final String footer) {
<span class="nc" id="L527">        printHelp(width, cmdLineSyntax, header, options, footer, false);</span>
<span class="nc" id="L528">    }</span>

    /**
     * Prints the help for {@code options} with the specified command line syntax. This method prints help information
     * to {@link System#out} by default.
     *
     * @param width the number of characters to be displayed on each line
     * @param cmdLineSyntax the syntax for this application
     * @param header the banner to display at the beginning of the help
     * @param options the Options instance
     * @param footer the banner to display at the end of the help
     * @param autoUsage whether to print an automatically generated usage statement
     */
    public void printHelp(final int width, final String cmdLineSyntax, final String header, final Options options, final String footer,
        final boolean autoUsage) {
<span class="nc" id="L543">        final PrintWriter pw = new PrintWriter(printWriter);</span>
<span class="nc" id="L544">        printHelp(pw, width, cmdLineSyntax, header, options, getLeftPadding(), getDescPadding(), footer, autoUsage);</span>
<span class="nc" id="L545">        pw.flush();</span>
<span class="nc" id="L546">    }</span>

    /**
     * Prints the help for {@code options} with the specified command line syntax.
     *
     * @param pw the writer to which the help will be written
     * @param width the number of characters to be displayed on each line
     * @param cmdLineSyntax the syntax for this application
     * @param header the banner to display at the beginning of the help
     * @param options the Options instance
     * @param leftPad the number of characters of padding to be prefixed to each line
     * @param descPad the number of characters of padding to be prefixed to each description line
     * @param footer the banner to display at the end of the help
     *
     * @throws IllegalStateException if there is no room to print a line
     */
    public void printHelp(final PrintWriter pw, final int width, final String cmdLineSyntax, final String header, final Options options, final int leftPad,
        final int descPad, final String footer) {
<span class="nc" id="L564">        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);</span>
<span class="nc" id="L565">    }</span>

    /**
     * Prints the help for {@code options} with the specified command line syntax.
     *
     * @param pw the writer to which the help will be written
     * @param width the number of characters to be displayed on each line
     * @param cmdLineSyntax the syntax for this application
     * @param header the banner to display at the beginning of the help
     * @param options the Options instance
     * @param leftPad the number of characters of padding to be prefixed to each line
     * @param descPad the number of characters of padding to be prefixed to each description line
     * @param footer the banner to display at the end of the help
     * @param autoUsage whether to print an automatically generated usage statement
     * @throws IllegalStateException if there is no room to print a line
     */
    public void printHelp(final PrintWriter pw, final int width, final String cmdLineSyntax, final String header, final Options options, final int leftPad,
        final int descPad, final String footer, final boolean autoUsage) {
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">        if (Util.isEmpty(cmdLineSyntax)) {</span>
<span class="nc" id="L584">            throw new IllegalArgumentException(&quot;cmdLineSyntax not provided&quot;);</span>
        }
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">        if (autoUsage) {</span>
<span class="fc" id="L587">            printUsage(pw, width, cmdLineSyntax, options);</span>
        } else {
<span class="nc" id="L589">            printUsage(pw, width, cmdLineSyntax);</span>
        }
<span class="pc bpc" id="L591" title="2 of 4 branches missed.">        if (header != null &amp;&amp; !header.isEmpty()) {</span>
<span class="fc" id="L592">            printWrapped(pw, width, header);</span>
        }
<span class="fc" id="L594">        printOptions(pw, width, options, leftPad, descPad);</span>
<span class="pc bpc" id="L595" title="3 of 4 branches missed.">        if (footer != null &amp;&amp; !footer.isEmpty()) {</span>
<span class="nc" id="L596">            printWrapped(pw, width, footer);</span>
        }
<span class="fc" id="L598">    }</span>

    /**
     * Prints the help for {@code options} with the specified command line syntax. This method prints help information
     * to {@link System#out} by default.
     *
     * @param cmdLineSyntax the syntax for this application
     * @param options the Options instance
     */
    public void printHelp(final String cmdLineSyntax, final Options options) {
<span class="nc" id="L608">        printHelp(getWidth(), cmdLineSyntax, null, options, null, false);</span>
<span class="nc" id="L609">    }</span>

    /**
     * Prints the help for {@code options} with the specified command line syntax. This method prints help information
     * to {@link System#out} by default.
     *
     * @param cmdLineSyntax the syntax for this application
     * @param options the Options instance
     * @param autoUsage whether to print an automatically generated usage statement
     */
    public void printHelp(final String cmdLineSyntax, final Options options, final boolean autoUsage) {
<span class="nc" id="L620">        printHelp(getWidth(), cmdLineSyntax, null, options, null, autoUsage);</span>
<span class="nc" id="L621">    }</span>

    /**
     * Prints the help for {@code options} with the specified command line syntax. This method prints help information
     * to {@link System#out} by default.
     *
     * @param cmdLineSyntax the syntax for this application
     * @param header the banner to display at the beginning of the help
     * @param options the Options instance
     * @param footer the banner to display at the end of the help
     */
    public void printHelp(final String cmdLineSyntax, final String header, final Options options, final String footer) {
<span class="nc" id="L633">        printHelp(cmdLineSyntax, header, options, footer, false);</span>
<span class="nc" id="L634">    }</span>

    /**
     * Prints the help for {@code options} with the specified command line syntax. This method prints help information
     * to {@link System#out} by default.
     *
     * @param cmdLineSyntax the syntax for this application
     * @param header the banner to display at the beginning of the help
     * @param options the Options instance
     * @param footer the banner to display at the end of the help
     * @param autoUsage whether to print an automatically generated usage statement
     */
    public void printHelp(final String cmdLineSyntax, final String header, final Options options, final String footer, final boolean autoUsage) {
<span class="nc" id="L647">        printHelp(getWidth(), cmdLineSyntax, header, options, footer, autoUsage);</span>
<span class="nc" id="L648">    }</span>

    /**
     * Prints the help for the specified Options to the specified writer, using the specified width, left padding and
     * description padding.
     *
     * @param pw The printWriter to write the help to
     * @param width The number of characters to display per line
     * @param options The command line Options
     * @param leftPad the number of characters of padding to be prefixed to each line
     * @param descPad the number of characters of padding to be prefixed to each description line
     */
    public void printOptions(final PrintWriter pw, final int width, final Options options, final int leftPad, final int descPad) {
<span class="fc" id="L661">        final StringBuffer sb = new StringBuffer();</span>
<span class="fc" id="L662">        renderOptions(sb, width, options, leftPad, descPad);</span>
<span class="fc" id="L663">        pw.println(sb.toString());</span>
<span class="fc" id="L664">    }</span>

    /**
     * Prints the cmdLineSyntax to the specified writer, using the specified width.
     *
     * @param pw The printWriter to write the help to
     * @param width The number of characters per line for the usage statement.
     * @param cmdLineSyntax The usage statement.
     */
    public void printUsage(final PrintWriter pw, final int width, final String cmdLineSyntax) {
<span class="nc" id="L674">        final int argPos = cmdLineSyntax.indexOf(' ') + 1;</span>
<span class="nc" id="L675">        printWrapped(pw, width, getSyntaxPrefix().length() + argPos, getSyntaxPrefix() + cmdLineSyntax);</span>
<span class="nc" id="L676">    }</span>

    /**
     * Prints the usage statement for the specified application.
     *
     * @param pw The PrintWriter to print the usage statement
     * @param width The number of characters to display per line
     * @param app The application name
     * @param options The command line Options
     */
    public void printUsage(final PrintWriter pw, final int width, final String app, final Options options) {
        // initialize the string buffer
<span class="fc" id="L688">        final StringBuffer buff = new StringBuffer(getSyntaxPrefix()).append(app).append(Char.SP);</span>
        // create a list for processed option groups
<span class="fc" id="L690">        final Collection&lt;OptionGroup&gt; processedGroups = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L691">        final List&lt;Option&gt; optList = new ArrayList&lt;&gt;(options.getOptions());</span>
<span class="pc bpc" id="L692" title="1 of 2 branches missed.">        if (getOptionComparator() != null) {</span>
<span class="fc" id="L693">            Collections.sort(optList, getOptionComparator());</span>
        }
        // iterate over the options
<span class="pc bpc" id="L696" title="1 of 2 branches missed.">        for (final Iterator&lt;Option&gt; it = optList.iterator(); it.hasNext();) {</span>
            // get the next Option
<span class="nc" id="L698">            final Option option = it.next();</span>
            // check if the option is part of an OptionGroup
<span class="nc" id="L700">            final OptionGroup group = options.getOptionGroup(option);</span>
            // if the option is part of a group
<span class="nc bnc" id="L702" title="All 2 branches missed.">            if (group != null) {</span>
                // and if the group has not already been processed
<span class="nc bnc" id="L704" title="All 2 branches missed.">                if (!processedGroups.contains(group)) {</span>
                    // add the group to the processed list
<span class="nc" id="L706">                    processedGroups.add(group);</span>
                    // add the usage clause
<span class="nc" id="L708">                    appendOptionGroup(buff, group);</span>
                }
                // otherwise the option was displayed in the group
                // previously so ignore it.
            }
            // if the Option is not part of an OptionGroup
            else {
<span class="nc" id="L715">                appendOption(buff, option, option.isRequired());</span>
            }
<span class="nc bnc" id="L717" title="All 2 branches missed.">            if (it.hasNext()) {</span>
<span class="nc" id="L718">                buff.append(Char.SP);</span>
            }
<span class="nc" id="L720">        }</span>

        // call printWrapped
<span class="fc" id="L723">        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());</span>
<span class="fc" id="L724">    }</span>

    /**
     * Prints the specified text to the specified PrintWriter.
     *
     * @param pw The printWriter to write the help to
     * @param width The number of characters to display per line
     * @param nextLineTabStop The position on the next line for the first tab.
     * @param text The text to be written to the PrintWriter
     */
    public void printWrapped(final PrintWriter pw, final int width, final int nextLineTabStop, final String text) {
<span class="fc" id="L735">        final StringBuffer sb = new StringBuffer(text.length());</span>
<span class="fc" id="L736">        renderWrappedTextBlock(sb, width, nextLineTabStop, text);</span>
<span class="fc" id="L737">        pw.println(sb.toString());</span>
<span class="fc" id="L738">    }</span>

    /**
     * Prints the specified text to the specified PrintWriter.
     *
     * @param pw The printWriter to write the help to
     * @param width The number of characters to display per line
     * @param text The text to be written to the PrintWriter
     */
    public void printWrapped(final PrintWriter pw, final int width, final String text) {
<span class="fc" id="L748">        printWrapped(pw, width, 0, text);</span>
<span class="fc" id="L749">    }</span>

    /**
     * Renders the specified Options and return the rendered Options in a StringBuffer.
     *
     * @param sb The StringBuffer to place the rendered Options into.
     * @param width The number of characters to display per line
     * @param options The command line Options
     * @param leftPad the number of characters of padding to be prefixed to each line
     * @param descPad the number of characters of padding to be prefixed to each description line
     *
     * @return the StringBuffer with the rendered Options contents.
     */
    protected StringBuffer renderOptions(final StringBuffer sb, final int width, final Options options, final int leftPad, final int descPad) {
<span class="fc" id="L763">        final String lpad = createPadding(leftPad);</span>
<span class="fc" id="L764">        final String dpad = createPadding(descPad);</span>
        // first create list containing only &lt;lpad&gt;-a,--aaa where
        // -a is opt and --aaa is long opt; in parallel look for
        // the longest opt string this list will be then used to
        // sort options ascending
<span class="fc" id="L769">        int max = 0;</span>
<span class="fc" id="L770">        final List&lt;StringBuffer&gt; prefixList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L771">        final List&lt;Option&gt; optList = options.helpOptions();</span>
<span class="pc bpc" id="L772" title="1 of 2 branches missed.">        if (getOptionComparator() != null) {</span>
<span class="fc" id="L773">            Collections.sort(optList, getOptionComparator());</span>
        }
<span class="pc bpc" id="L775" title="1 of 2 branches missed.">        for (final Option option : optList) {</span>
<span class="nc" id="L776">            final StringBuffer optBuf = new StringBuffer();</span>
<span class="nc bnc" id="L777" title="All 2 branches missed.">            if (option.getOpt() == null) {</span>
<span class="nc" id="L778">                optBuf.append(lpad).append(&quot;   &quot;).append(getLongOptPrefix()).append(option.getLongOpt());</span>
            } else {
<span class="nc" id="L780">                optBuf.append(lpad).append(getOptPrefix()).append(option.getOpt());</span>
<span class="nc bnc" id="L781" title="All 2 branches missed.">                if (option.hasLongOpt()) {</span>
<span class="nc" id="L782">                    optBuf.append(',').append(getLongOptPrefix()).append(option.getLongOpt());</span>
                }
            }
<span class="nc bnc" id="L785" title="All 2 branches missed.">            if (option.hasArg()) {</span>
<span class="nc" id="L786">                final String argName = option.getArgName();</span>
<span class="nc bnc" id="L787" title="All 4 branches missed.">                if (argName != null &amp;&amp; argName.isEmpty()) {</span>
                    // if the option has a blank argname
<span class="nc" id="L789">                    optBuf.append(' ');</span>
                } else {
<span class="nc bnc" id="L791" title="All 2 branches missed.">                    optBuf.append(option.hasLongOpt() ? longOptSeparator : &quot; &quot;);</span>
<span class="nc bnc" id="L792" title="All 2 branches missed.">                    optBuf.append(&quot;&lt;&quot;).append(argName != null ? option.getArgName() : getArgName()).append(&quot;&gt;&quot;);</span>
                }
            }
<span class="nc" id="L795">            prefixList.add(optBuf);</span>
<span class="nc" id="L796">            max = Math.max(optBuf.length(), max);</span>
<span class="nc" id="L797">        }</span>
<span class="fc" id="L798">        int x = 0;</span>
<span class="pc bpc" id="L799" title="1 of 2 branches missed.">        for (final Iterator&lt;Option&gt; it = optList.iterator(); it.hasNext();) {</span>
<span class="nc" id="L800">            final Option option = it.next();</span>
<span class="nc" id="L801">            final StringBuilder optBuf = new StringBuilder(prefixList.get(x++).toString());</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">            if (optBuf.length() &lt; max) {</span>
<span class="nc" id="L803">                optBuf.append(createPadding(max - optBuf.length()));</span>
            }
<span class="nc" id="L805">            optBuf.append(dpad);</span>
<span class="nc" id="L806">            final int nextLineTabStop = max + descPad;</span>
<span class="nc bnc" id="L807" title="All 4 branches missed.">            if (deprecatedFormatFunc != null &amp;&amp; option.isDeprecated()) {</span>
<span class="nc" id="L808">                optBuf.append(deprecatedFormatFunc.apply(option).trim());</span>
<span class="nc bnc" id="L809" title="All 2 branches missed.">            } else if (option.getDescription() != null) {</span>
<span class="nc" id="L810">                optBuf.append(option.getDescription());</span>
            }
<span class="nc" id="L812">            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());</span>
<span class="nc bnc" id="L813" title="All 2 branches missed.">            if (it.hasNext()) {</span>
<span class="nc" id="L814">                sb.append(getNewLine());</span>
            }
<span class="nc" id="L816">        }</span>
<span class="fc" id="L817">        return sb;</span>
    }

    /**
     * Renders the specified text and return the rendered Options in a StringBuffer.
     *
     * @param sb The StringBuffer to place the rendered text into.
     * @param width The number of characters to display per line
     * @param nextLineTabStop The position on the next line for the first tab.
     * @param text The text to be rendered.
     *
     * @return the StringBuffer with the rendered Options contents.
     */
    protected StringBuffer renderWrappedText(final StringBuffer sb, final int width, final int nextLineTabStop, final String text) {
<span class="fc" id="L831">        String render = text;</span>
<span class="fc" id="L832">        int nextLineTabStopPos = nextLineTabStop;</span>
<span class="fc" id="L833">        int pos = findWrapPos(render, width, 0);</span>
<span class="pc bpc" id="L834" title="1 of 2 branches missed.">        if (pos == -1) {</span>
<span class="fc" id="L835">            sb.append(rtrim(render));</span>
<span class="fc" id="L836">            return sb;</span>
        }
<span class="nc" id="L838">        sb.append(rtrim(render.substring(0, pos))).append(getNewLine());</span>
<span class="nc bnc" id="L839" title="All 2 branches missed.">        if (nextLineTabStopPos &gt;= width) {</span>
            // stops infinite loop happening
<span class="nc" id="L841">            nextLineTabStopPos = 1;</span>
        }
        // all following lines must be padded with nextLineTabStop space characters
<span class="nc" id="L844">        final String padding = createPadding(nextLineTabStopPos);</span>
        while (true) {
<span class="nc" id="L846">            render = padding + render.substring(pos).trim();</span>
<span class="nc" id="L847">            pos = findWrapPos(render, width, 0);</span>
<span class="nc bnc" id="L848" title="All 2 branches missed.">            if (pos == -1) {</span>
<span class="nc" id="L849">                sb.append(render);</span>
<span class="nc" id="L850">                return sb;</span>
            }
<span class="nc bnc" id="L852" title="All 4 branches missed.">            if (render.length() &gt; width &amp;&amp; pos == nextLineTabStopPos - 1) {</span>
<span class="nc" id="L853">                pos = width;</span>
            }
<span class="nc" id="L855">            sb.append(rtrim(render.substring(0, pos))).append(getNewLine());</span>
        }
    }

    /**
     * Renders the specified text width a maximum width. This method differs from renderWrappedText by not removing leading
     * spaces after a new line.
     *
     * @param sb The StringBuffer to place the rendered text into.
     * @param width The number of characters to display per line
     * @param nextLineTabStop The position on the next line for the first tab.
     * @param text The text to be rendered.
     */
    private Appendable renderWrappedTextBlock(final StringBuffer sb, final int width, final int nextLineTabStop, final String text) {
        try {
<span class="fc" id="L870">            final BufferedReader in = new BufferedReader(new StringReader(text));</span>
            String line;
<span class="fc" id="L872">            boolean firstLine = true;</span>
<span class="fc bfc" id="L873" title="All 2 branches covered.">            while ((line = in.readLine()) != null) {</span>
<span class="pc bpc" id="L874" title="1 of 2 branches missed.">                if (!firstLine) {</span>
<span class="nc" id="L875">                    sb.append(getNewLine());</span>
                } else {
<span class="fc" id="L877">                    firstLine = false;</span>
                }
<span class="fc" id="L879">                renderWrappedText(sb, width, nextLineTabStop, line);</span>
            }
<span class="nc" id="L881">        } catch (final IOException e) { // NOPMD</span>
            // cannot happen
<span class="fc" id="L883">        }</span>
<span class="fc" id="L884">        return sb;</span>
    }

    /**
     * Removes the trailing whitespace from the specified String.
     *
     * @param s The String to remove the trailing padding from.
     * @return The String of without the trailing padding
     */
    protected String rtrim(final String s) {
<span class="pc bpc" id="L894" title="1 of 2 branches missed.">        if (Util.isEmpty(s)) {</span>
<span class="nc" id="L895">            return s;</span>
        }
<span class="fc" id="L897">        int pos = s.length();</span>
<span class="pc bpc" id="L898" title="1 of 4 branches missed.">        while (pos &gt; 0 &amp;&amp; Character.isWhitespace(s.charAt(pos - 1))) {</span>
<span class="fc" id="L899">            --pos;</span>
        }
<span class="fc" id="L901">        return s.substring(0, pos);</span>
    }

    /**
     * Sets the 'argName'.
     *
     * @param name the new value of 'argName'
     */
    public void setArgName(final String name) {
<span class="nc" id="L910">        this.defaultArgName = name;</span>
<span class="nc" id="L911">    }</span>

    /**
     * Sets the 'descPadding'.
     *
     * @param padding the new value of 'descPadding'
     */
    public void setDescPadding(final int padding) {
<span class="nc" id="L919">        this.defaultDescPad = padding;</span>
<span class="nc" id="L920">    }</span>

    /**
     * Sets the 'leftPadding'.
     *
     * @param padding the new value of 'leftPadding'
     */
    public void setLeftPadding(final int padding) {
<span class="nc" id="L928">        this.defaultLeftPad = padding;</span>
<span class="nc" id="L929">    }</span>

    /**
     * Sets the 'longOptPrefix'.
     *
     * @param prefix the new value of 'longOptPrefix'
     */
    public void setLongOptPrefix(final String prefix) {
<span class="nc" id="L937">        this.defaultLongOptPrefix = prefix;</span>
<span class="nc" id="L938">    }</span>

    /**
     * Sets the separator displayed between a long option and its value. Ensure that the separator specified is supported by
     * the parser used, typically ' ' or '='.
     *
     * @param longOptSeparator the separator, typically ' ' or '='.
     * @since 1.3
     */
    public void setLongOptSeparator(final String longOptSeparator) {
<span class="nc" id="L948">        this.longOptSeparator = longOptSeparator;</span>
<span class="nc" id="L949">    }</span>

    /**
     * Sets the 'newLine'.
     *
     * @param newline the new value of 'newLine'
     */
    public void setNewLine(final String newline) {
<span class="nc" id="L957">        this.defaultNewLine = newline;</span>
<span class="nc" id="L958">    }</span>

    /**
     * Sets the comparator used to sort the options when they output in help text. Passing in a null comparator will keep the
     * options in the order they were declared.
     *
     * @param comparator the {@link Comparator} to use for sorting the options
     * @since 1.2
     */
    public void setOptionComparator(final Comparator&lt;Option&gt; comparator) {
<span class="nc" id="L968">        this.optionComparator = comparator;</span>
<span class="nc" id="L969">    }</span>

    /**
     * Sets the 'optPrefix'.
     *
     * @param prefix the new value of 'optPrefix'
     */
    public void setOptPrefix(final String prefix) {
<span class="nc" id="L977">        this.defaultOptPrefix = prefix;</span>
<span class="nc" id="L978">    }</span>

    /**
     * Sets the 'syntaxPrefix'.
     *
     * @param prefix the new value of 'syntaxPrefix'
     */
    public void setSyntaxPrefix(final String prefix) {
<span class="nc" id="L986">        this.defaultSyntaxPrefix = prefix;</span>
<span class="nc" id="L987">    }</span>

    /**
     * Sets the 'width'.
     *
     * @param width the new value of 'width'
     */
    public void setWidth(final int width) {
<span class="nc" id="L995">        this.defaultWidth = width;</span>
<span class="nc" id="L996">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>